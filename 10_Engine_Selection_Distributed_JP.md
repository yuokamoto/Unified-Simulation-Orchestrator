# 10. エンジン選定基準と分散シミュレーションの理由

## 複数シミュレーションエンジンを採用する理由

1. **用途ごとの最適化**
   - **SimPy**:
     - Pythonベースのイベント駆動型シミュレーションフレームワーク。
     - 軽量で大規模シナリオにスケールしやすい。
     - 物理演算を行わず、スケジューリングやプロセスロジックの高速検証に最適。
   - **Gazebo**:
     - ROS2と統合しやすく、URDF/SDFをネイティブサポート。
     - センサーやダイナミクスを含む現実的な物理シミュレーションが可能。
     - 動作計画や動的インタラクション（衝突、力学挙動）の検証に最適。
   - **Mujoco / Genesis**:
     - ロボティクス分野向けの高性能な物理演算が可能。
     - 細かいダイナミクスや制御アルゴリズムの研究に向く。
   - **Isaac Sim / Unreal Engine**:
     - 高品質な3Dビジュアライゼーションやマーケティングデモ、ML用データセット生成に有効。

2. **資産とロジックの共通利用**
   - **Open-USD**:
     - 複雑な3Dアセット、マテリアル、アニメーションを表現可能。
     - OmniverseやUnrealなど主要なレンダリングパイプラインで利用可能。
     - 複数エンジンでのビジュアライゼーション資産を共通化。
   - **URDF / SDF**:
     - ロボットや環境の物理的特性を記述する標準フォーマット。
     - GazeboやROS2と互換性が高く、他エンジンにも変換可能。
   - **YAML（スナップショット）**:
     - 人間可読で、Python/C++間で扱いやすい。
     - 時系列の世界状態（位置・速度・状態・接続関係）を表現。
   - **Behavior Tree (BT) 共通XML**:
     - `BehaviorTree.CPP` に準拠しつつ、`py_trees` などに変換可能。
     - Groot2などのGUIで編集可能で、C++とPython間で共通利用。

3. **シナリオとスナップショットの分離**
   - **シナリオ**:
     - タスク、イベント、ミッションの意図を記述。
     - 初期状態スナップショットを参照することで、世界の開始状態を管理。
   - **スナップショット**:
     - 特定時刻の世界の状態を記述し、初期化、同期、リプレイに利用。
     - シミュレーションエンジンに依存しないデータ形式。

---

## 通信・ミドルウェア選定理由

1. **gRPC（コア通信）**
   - 高速かつ型安全な双方向通信が可能。
   - マルチランゲージ対応（Python, C++, JavaScript など）で、フレームワーク内の多様なスタックを統一。
   - ストリーミングや双方向通信（シミュレーション状態・イベント通知）をサポート。

2. **ROS 2（ラッパーとして）**
   - ロボティクス分野での標準的な通信基盤。
   - 実ロボットとの統合や、既存のROS2ノード群との接続が容易。
   - コアではなくラッパーとして使用することで、**シミュレーション内部の複雑さを回避しつつ、外部連携の利便性を確保**。

3. **ZeroMQ（内部状態同期）**
   - 分散シミュレーションにおける高速で軽量なメッセージングに適する。
   - gRPCよりも低レイテンシで、シミュレーションノード間の頻繁な状態転送や差分スナップショット送信に向く。
   - 高スループットを必要とするシーン（差分同期）で有効。

---

## 分散シミュレーションを採用する理由

1. **スケーラビリティ**
   - 数百～数千のエージェントを含む工場や倉庫シナリオでは、  
     単一プロセスでは処理が追いつかず、複数ノードへの分散が必要。

2. **リソースの柔軟活用**
   - 計算負荷の高い物理演算や3DレンダリングノードはGPUサーバーに、  
     軽量なロジックノードはCPUサーバーに分散配置できる。

3. **フォールトトレランス**
   - ノード障害時でも、Redisにキャッシュされたスナップショットから復旧可能。
   - 長時間のシミュレーションで安定性を確保。

4. **チーム開発の効率化**
   - ロジック検証チームと物理検証チームが同時並行で作業可能。
   - 分散構成により、大規模シナリオを実行しながら小規模単体テストも容易。

---

## シングルモードの意義
- 小規模テストやデバッグ用に、**Simulation Masterを簡略化し、ノードを単一プロセスで実行**できる。  
- 通信や同期処理を省略し、高速なシミュレーションを可能にする。
- 同じアーキテクチャを用いるため、シングルモードから分散モードへの移行も容易。

---

## これらの選択で実現される設計目標

1. **スケーラビリティ**  
   - SimPyでの軽量分散ロジック、Gazebo/Mujocoでの詳細物理により、規模や精度の要件に柔軟対応。

2. **再利用性**  
   - Open-USD、URDF/SDF、YAMLスナップショット、共通BTにより、複数エンジン間で資産・ロジックを共通化。

3. **通信効率**  
   - gRPCでの外部接続、ZeroMQでの内部高速通信により、柔軟で高性能な分散アーキテクチャを実現。

4. **使いやすさ**  
   - Groot2 GUIでのBT編集、人間可読のYAML、標準的なオープンフォーマットにより、  
     非エンジニアも利用可能な環境を実現。
